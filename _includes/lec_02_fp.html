<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>lec_02_fp</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library lec_02_fp</h1>

<div class="code">
</div>

<div class="doc">
<a id="lab1"></a><h1 class="section">Functional Programming in Coq</h1>

<div class="paragraph"> </div>

<a id="lab2"></a><h2 class="section">References</h2>


<div class="paragraph"> </div>

<ul class="doclist">
<li> https://softwarefoundations.cis.upenn.edu/lf-current/Lists.html

</li>
<li> https://softwarefoundations.cis.upenn.edu/lf-current/Poly.html

</li>
</ul>
 
<div class="paragraph"> </div>

<a id="lab3"></a><h2 class="section">Recap</h2>


<div class="paragraph"> </div>

<ul class="doclist">
<li> Last time, we saw that we could define basic data types in Coq including

</li>
</ul>
  booleans and natural numbers.
<ul class="doclist">
<li> These data types are *syntactic* objects that have no *semantics*, i.e.,

</li>
</ul>
  meaning associated with them.
<ul class="doclist">
<li> We had to prove proerties of those data types to show that booleans indeed

</li>
</ul>
  behaved liked booleans and naturals behaved like natural numbers.
<ul class="doclist">
<li> Before we can explore the rich world of mechanized proofs, we will need to

</li>
</ul>
  get more comfortable defining complex data types and operations on them.

<div class="paragraph"> </div>

<a id="lab4"></a><h2 class="section">Goal for today</h2>


<div class="paragraph"> </div>

<ul class="doclist">
<li> More data types in Coq including product and lists

</li>
<li> Polymorphism in Coq

</li>
<li> Higher-order functions in Coq

</li>
</ul>
 
<div class="paragraph"> </div>

<a id="lab5"></a><h2 class="section">Pair of natural numbers</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a id="NatProd" class="idref" href="#NatProd"><span class="id" title="module">NatProd</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a id="NatProd.natprod" class="idref" href="#NatProd.natprod"><span class="id" title="inductive">natprod</span></a>: <span class="id" title="keyword">Type</span> :=<br/>
| <a id="NatProd.mkNatProd" class="idref" href="#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#natprod:1"><span class="id" title="inductive">natprod</span></a>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> 0 2.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> 20 13.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> We can now make tuples with the *constructor* <span class="inlinecode"><span class="id" title="var">mkNatProd</span></span>.

</li>
<li> We may also refer to <span class="inlinecode"><span class="id" title="var">mkNatProd</span></span> as an *introduction* form.

</li>
<li> How do we compute with natprod? We may need a rule for *eliminating* them.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="NatProd.fst" class="idref" href="#NatProd.fst"><span class="id" title="definition">fst</span></a> (<a id="p:3" class="idref" href="#p:3"><span class="id" title="binder">p</span></a>: <a class="idref" href="lec_02_fp.html#NatProd.natprod"><span class="id" title="inductive">natprod</span></a>): <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#p:3"><span class="id" title="variable">p</span></a> <span class="id" title="keyword">with</span>          <span class="comment">(*&nbsp;we&nbsp;can&nbsp;pattern&nbsp;match&nbsp;even&nbsp;if&nbsp;there&nbsp;is&nbsp;only&nbsp;1&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> <span class="id" title="var">n</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">n</span>  <span class="comment">(*&nbsp;_&nbsp;means&nbsp;we&nbsp;don't&nbsp;care&nbsp;what&nbsp;it&nbsp;is&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#NatProd.fst"><span class="id" title="definition">fst</span></a>.<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;natprod&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Compute</span> (<a class="idref" href="lec_02_fp.html#NatProd.fst"><span class="id" title="definition">fst</span></a> (<a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> 0 1)).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="NatProd.snd" class="idref" href="#NatProd.snd"><span class="id" title="definition">snd</span></a> (<a id="p:5" class="idref" href="#p:5"><span class="id" title="binder">p</span></a>: <a class="idref" href="lec_02_fp.html#NatProd.natprod"><span class="id" title="inductive">natprod</span></a>): <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#p:5"><span class="id" title="variable">p</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#NatProd.snd"><span class="id" title="definition">snd</span></a>.<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;natprod&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Compute</span> (<a class="idref" href="lec_02_fp.html#NatProd.snd"><span class="id" title="definition">snd</span></a> (<a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> 0 1)).<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Like our other inductive data types, we can check that natprod behaves
    like a product of natural numbers.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatProd.intro_elim1" class="idref" href="#NatProd.intro_elim1"><span class="id" title="lemma">intro_elim1</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<a id="n:7" class="idref" href="#n:7"><span class="id" title="binder">n</span></a> <a id="m:8" class="idref" href="#m:8"><span class="id" title="binder">m</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#NatProd.fst"><span class="id" title="definition">fst</span></a> (<a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> <a class="idref" href="lec_02_fp.html#n:7"><span class="id" title="variable">n</span></a> <a class="idref" href="lec_02_fp.html#m:8"><span class="id" title="variable">m</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#n:7"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatProd.intro_elim2" class="idref" href="#NatProd.intro_elim2"><span class="id" title="lemma">intro_elim2</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<a id="n:9" class="idref" href="#n:9"><span class="id" title="binder">n</span></a> <a id="m:10" class="idref" href="#m:10"><span class="id" title="binder">m</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#NatProd.snd"><span class="id" title="definition">snd</span></a> (<a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> <a class="idref" href="lec_02_fp.html#n:9"><span class="id" title="variable">n</span></a> <a class="idref" href="lec_02_fp.html#m:10"><span class="id" title="variable">m</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#m:10"><span class="id" title="variable">m</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Another "natural" oepration to perform on products is to swap their
    elements.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="NatProd.swap" class="idref" href="#NatProd.swap"><span class="id" title="definition">swap</span></a> (<a id="p:11" class="idref" href="#p:11"><span class="id" title="binder">p</span></a>: <a class="idref" href="lec_02_fp.html#NatProd.natprod"><span class="id" title="inductive">natprod</span></a>): <a class="idref" href="lec_02_fp.html#NatProd.natprod"><span class="id" title="inductive">natprod</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#p:11"><span class="id" title="variable">p</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> <span class="id" title="var">n</span> <span class="id" title="var">m</span> =&gt; <a class="idref" href="lec_02_fp.html#NatProd.mkNatProd"><span class="id" title="constructor">mkNatProd</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Like before, we should check that swap indeed has the behavior that
    we expect it to have.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatProd.swap_works1" class="idref" href="#NatProd.swap_works1"><span class="id" title="lemma">swap_works1</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<a id="p:13" class="idref" href="#p:13"><span class="id" title="binder">p</span></a>: <a class="idref" href="lec_02_fp.html#NatProd.natprod"><span class="id" title="inductive">natprod</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#NatProd.fst"><span class="id" title="definition">fst</span></a> <a class="idref" href="lec_02_fp.html#p:13"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#NatProd.snd"><span class="id" title="definition">snd</span></a> (<a class="idref" href="lec_02_fp.html#NatProd.swap"><span class="id" title="definition">swap</span></a> <a class="idref" href="lec_02_fp.html#p:13"><span class="id" title="variable">p</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> We should expect a symmetric situation to hold for <span class="inlinecode"><span class="id" title="var">snd</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>.

</li>
<li> But before we do that, let's prove another theorem first. 

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatProd.swap_swap_idempotent" class="idref" href="#NatProd.swap_swap_idempotent"><span class="id" title="lemma">swap_swap_idempotent</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<a id="p:14" class="idref" href="#p:14"><span class="id" title="binder">p</span></a>: <a class="idref" href="lec_02_fp.html#NatProd.natprod"><span class="id" title="inductive">natprod</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#NatProd.swap"><span class="id" title="definition">swap</span></a> (<a class="idref" href="lec_02_fp.html#NatProd.swap"><span class="id" title="definition">swap</span></a> <a class="idref" href="lec_02_fp.html#p:14"><span class="id" title="variable">p</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#p:14"><span class="id" title="variable">p</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Let's try to use <span class="inlinecode"><span class="id" title="var">swap_swap_idempotent</span></span> to prove the other version of <span class="inlinecode"><span class="id" title="var">swap_works1</span></span>.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatProd.swap_works2" class="idref" href="#NatProd.swap_works2"><span class="id" title="lemma">swap_works2</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<a id="p:15" class="idref" href="#p:15"><span class="id" title="binder">p</span></a>: <a class="idref" href="lec_02_fp.html#NatProd.natprod"><span class="id" title="inductive">natprod</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#NatProd.snd"><span class="id" title="definition">snd</span></a> <a class="idref" href="lec_02_fp.html#p:15"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#NatProd.fst"><span class="id" title="definition">fst</span></a> (<a class="idref" href="lec_02_fp.html#NatProd.swap"><span class="id" title="definition">swap</span></a> <a class="idref" href="lec_02_fp.html#p:15"><span class="id" title="variable">p</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;substitute&nbsp;all&nbsp;reference&nbsp;of&nbsp;fst&nbsp;p&nbsp;with&nbsp;snd&nbsp;(swap&nbsp;p)&nbsp;for&nbsp;any&nbsp;p&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="lec_02_fp.html#NatProd.swap_works1"><span class="id" title="lemma">swap_works1</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;substitute&nbsp;all&nbsp;references&nbsp;of&nbsp;swap&nbsp;(swap&nbsp;p)&nbsp;with&nbsp;p&nbsp;for&nbsp;any&nbsp;p&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> -&gt; <a class="idref" href="lec_02_fp.html#NatProd.swap_swap_idempotent"><span class="id" title="lemma">swap_swap_idempotent</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab6"></a><h3 class="section">Summary</h3>


<div class="paragraph"> </div>

<ul class="doclist">
<li> We defined pairs of natural numbers.

</li>
<li> This is an example of an inductive type that has only one constructor.

</li>
<li> We saw an example proof where we use previous theorems to prove the current one.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="lec_02_fp.html#NatProd"><span class="id" title="module">NatProd</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> What is we want an arbitrary number of natural numbers?

</li>
<li> We accomplish this with list data types.

</li>
<li> Lists are a fundamental data structure. It can, for example, be used
    to model an idealized version of computer memory where the address is an
    integer index and the contents is a natural number. That natural number
    can be interpreted as encoding some value.

</li>
</ul>

<div class="paragraph"> </div>

<a id="lab7"></a><h2 class="section">List Types</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a id="NatList" class="idref" href="#NatList"><span class="id" title="module">NatList</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a id="NatList.natlist" class="idref" href="#NatList.natlist"><span class="id" title="inductive">natlist</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
| <a id="NatList.nil" class="idref" href="#NatList.nil"><span class="id" title="constructor">nil</span></a> : <a class="idref" href="lec_02_fp.html#natlist:16"><span class="id" title="inductive">natlist</span></a><br/>
| <a id="NatList.cons" class="idref" href="#NatList.cons"><span class="id" title="constructor">cons</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#natlist:16"><span class="id" title="inductive">natlist</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#natlist:16"><span class="id" title="inductive">natlist</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="NatList.ls1" class="idref" href="#NatList.ls1"><span class="id" title="definition">ls1</span></a> := <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.ls1"><span class="id" title="definition">ls1</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="NatList.ls2" class="idref" href="#NatList.ls2"><span class="id" title="definition">ls2</span></a> := <a class="idref" href="lec_02_fp.html#NatList.cons"><span class="id" title="constructor">cons</span></a> 1 <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.ls2"><span class="id" title="definition">ls2</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;<span class="inlinecode">2,</span> <span class="inlinecode">1</span>&nbsp;*)</span><br/>
<span class="id" title="keyword">Definition</span> <a id="NatList.ls3" class="idref" href="#NatList.ls3"><span class="id" title="definition">ls3</span></a> := <a class="idref" href="lec_02_fp.html#NatList.cons"><span class="id" title="constructor">cons</span></a> 2 (<a class="idref" href="lec_02_fp.html#NatList.cons"><span class="id" title="constructor">cons</span></a> 1 <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a>).<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.ls3"><span class="id" title="definition">ls3</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;<span class="inlinecode">1,</span> <span class="inlinecode">2</span>&nbsp;*)</span><br/>
<span class="id" title="keyword">Definition</span> <a id="NatList.ls4" class="idref" href="#NatList.ls4"><span class="id" title="definition">ls4</span></a> := <a class="idref" href="lec_02_fp.html#NatList.cons"><span class="id" title="constructor">cons</span></a> 1 (<a class="idref" href="lec_02_fp.html#NatList.cons"><span class="id" title="constructor">cons</span></a> 2 <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a>).<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.ls4"><span class="id" title="definition">ls4</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> As with natural numbers, we can define notation that will make it
    easier to work with lists.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a id="f5cee4f22b9033d1d704f9d537452cd0" class="idref" href="#f5cee4f22b9033d1d704f9d537452cd0"><span class="id" title="notation">&quot;</span></a>[ ]" := <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a id="NatList.:::x_'::'_x" class="idref" href="#NatList.:::x_'::'_x"><span class="id" title="notation">&quot;</span></a>x :: l" := (<a class="idref" href="lec_02_fp.html#NatList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">x</span> <span class="id" title="var">l</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a id="62815778618d6f51cd0f9ac90bf0e8be" class="idref" href="#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">&quot;</span></a>[ x ; .. ; y ]" := (<a class="idref" href="lec_02_fp.html#NatList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">x</span> .. (<a class="idref" href="lec_02_fp.html#NatList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">y</span> <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a>) ..).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="NatList.ls1'" class="idref" href="#NatList.ls1'"><span class="id" title="definition">ls1'</span></a> := <a class="idref" href="lec_02_fp.html#f5cee4f22b9033d1d704f9d537452cd0"><span class="id" title="notation">[]</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.ls1'"><span class="id" title="definition">ls1'</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="NatList.ls2'" class="idref" href="#NatList.ls2'"><span class="id" title="definition">ls2'</span></a> := <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>1<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.ls2'"><span class="id" title="definition">ls2'</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="NatList.ls3'" class="idref" href="#NatList.ls3'"><span class="id" title="definition">ls3'</span></a> := <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>2<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 1<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a>. <span class="comment">(*&nbsp;Note&nbsp;that&nbsp;lists&nbsp;are&nbsp;built&nbsp;in&nbsp;reverse.&nbsp;*)</span><br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.ls3'"><span class="id" title="definition">ls3'</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> We just defined an inductive datatype that we wish to interpret as a list.

</li>
<li> As before, we need to define operations on that data type and then
    prove properties of those operations to show that the datatype can be
    interpreted with the usual semantics.

</li>
<li> One of the first things we may want to do with lists is to take them apart.

</li>
</ul>
 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> The programming langauge for Coq, called Gallina, is a pure functional
    programming language. That means that every function in Coq must be <i>total</i>
    like a standard mathematical function.

</li>
<li> We already run into a problem for getting the first element of a list, i.e.,
    the head of the list.

</li>
<li> Namely, what do we do for an empty list?

</li>
</ul>
 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="NatList.head" class="idref" href="#NatList.head"><span class="id" title="definition">head</span></a> (<a id="default:18" class="idref" href="#default:18"><span class="id" title="binder">default</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<a id="ls:19" class="idref" href="#ls:19"><span class="id" title="binder">ls</span></a> : <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>): <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:19"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a> =&gt; <a class="idref" href="lec_02_fp.html#default:18"><span class="id" title="variable">default</span></a>  <span class="comment">(*&nbsp;return&nbsp;a&nbsp;default&nbsp;element&nbsp;for&nbsp;a&nbsp;list&nbsp;*)</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">hd</span> <a class="idref" href="lec_02_fp.html#NatList.:::x_'::'_x"><span class="id" title="notation">::</span></a> <span class="id" title="var">tl</span> =&gt; <span class="id" title="var">hd</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.head"><span class="id" title="definition">head</span></a> 42 <a class="idref" href="lec_02_fp.html#f5cee4f22b9033d1d704f9d537452cd0"><span class="id" title="notation">[]</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.head"><span class="id" title="definition">head</span></a> 42 <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>1<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 2<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 3<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="NatList.tail" class="idref" href="#NatList.tail"><span class="id" title="definition">tail</span></a> (<a id="ls:21" class="idref" href="#ls:21"><span class="id" title="binder">ls</span></a> : <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>): <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:21"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a> =&gt; <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a><br/>
&nbsp;&nbsp;| <span class="id" title="var">hd</span> <a class="idref" href="lec_02_fp.html#NatList.:::x_'::'_x"><span class="id" title="notation">::</span></a> <span class="id" title="var">tl</span> =&gt; <span class="id" title="var">tl</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.tail"><span class="id" title="definition">tail</span></a> <a class="idref" href="lec_02_fp.html#f5cee4f22b9033d1d704f9d537452cd0"><span class="id" title="notation">[]</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatList.tail"><span class="id" title="definition">tail</span></a> <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>1<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 2<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 3<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Some other operations we may want to perform on lists include getting
    its length and appending lists.

</li>
</ul>
  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="NatList.length'" class="idref" href="#NatList.length'"><span class="id" title="definition">length'</span></a> (<a id="ls:23" class="idref" href="#ls:23"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>): <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:23"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a> =&gt; 0<br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">tl</span> =&gt; 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#length':24"><span class="id" title="definition">length'</span></a> <span class="id" title="var">tl</span><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> We can also pattern match on our notation.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Nat.html#add"><span class="id" title="definition">Nat.add</span></a>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="NatList.length" class="idref" href="#NatList.length"><span class="id" title="definition">length</span></a> (<a id="ls:26" class="idref" href="#ls:26"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:26"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a> =&gt; 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">_</span> <a class="idref" href="lec_02_fp.html#NatList.:::x_'::'_x"><span class="id" title="notation">::</span></a> <span class="id" title="var">tl</span> =&gt; 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#length:27"><span class="id" title="definition">length</span></a> <span class="id" title="var">tl</span><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a> <span class="comment">(*&nbsp;Question:&nbsp;what&nbsp;if&nbsp;we&nbsp;wrote&nbsp;S&nbsp;(length&nbsp;tl)?&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Question:&nbsp;what&nbsp;if&nbsp;we&nbsp;wrote&nbsp;length&nbsp;tl&nbsp;+&nbsp;1?&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="NatList.append" class="idref" href="#NatList.append"><span class="id" title="definition">append</span></a> (<a id="ls1:29" class="idref" href="#ls1:29"><span class="id" title="binder">ls1</span></a> <a id="ls2:30" class="idref" href="#ls2:30"><span class="id" title="binder">ls2</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>): <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls1:29"><span class="id" title="variable">ls1</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a> =&gt; <a class="idref" href="lec_02_fp.html#ls2:30"><span class="id" title="variable">ls2</span></a><br/>
&nbsp;&nbsp;| <span class="id" title="var">hd</span> <a class="idref" href="lec_02_fp.html#NatList.:::x_'::'_x"><span class="id" title="notation">::</span></a> <span class="id" title="var">tl</span> =&gt; <span class="id" title="var">hd</span> <a class="idref" href="lec_02_fp.html#NatList.:::x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="lec_02_fp.html#NatList.:::x_'::'_x"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#append:31"><span class="id" title="definition">append</span></a> <span class="id" title="var">tl</span> <a class="idref" href="lec_02_fp.html#ls2:30"><span class="id" title="variable">ls2</span></a><a class="idref" href="lec_02_fp.html#NatList.:::x_'::'_x"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Some helpful notation for appending lists.

</li>
</ul>
 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <a id="9051c98c6b1a5a76d335ab187bb449a6" class="idref" href="#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">&quot;</span></a>x ++ y" := (<a class="idref" href="lec_02_fp.html#NatList.append"><span class="id" title="definition">append</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60).<br/>

<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>1<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#f5cee4f22b9033d1d704f9d537452cd0"><span class="id" title="notation">[]</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>1<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 2<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>3<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 4<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>1<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 2<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 3<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>4<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> It's time to prove some theorems!

</li>
<li> Let's start with <span class="inlinecode"><span class="id" title="var">tail</span></span>.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#pred"><span class="id" title="abbreviation">pred</span></a>.<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Nat.html#pred"><span class="id" title="definition">Nat.pred</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatList.tl_length_pred" class="idref" href="#NatList.tl_length_pred"><span class="id" title="lemma">tl_length_pred</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="ls:33" class="idref" href="#ls:33"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#pred"><span class="id" title="abbreviation">pred</span></a> (<a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#ls:33"><span class="id" title="variable">ls</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> (<a class="idref" href="lec_02_fp.html#NatList.tail"><span class="id" title="definition">tail</span></a> <a class="idref" href="lec_02_fp.html#ls:33"><span class="id" title="variable">ls</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">hd</span> <span class="id" title="var">tl</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls&nbsp;=&nbsp;cons&nbsp;hd&nbsp;tl&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> What if we used <span class="inlinecode">-</span> instead of <span class="inlinecode"><span class="id" title="var">pred</span></span>?

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatList.tl_length_minus1" class="idref" href="#NatList.tl_length_minus1"><span class="id" title="lemma">tl_length_minus1</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="ls:34" class="idref" href="#ls:34"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#ls:34"><span class="id" title="variable">ls</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#::nat_scope:x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> (<a class="idref" href="lec_02_fp.html#NatList.tail"><span class="id" title="definition">tail</span></a> <a class="idref" href="lec_02_fp.html#ls:34"><span class="id" title="variable">ls</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">hd</span> <span class="id" title="var">tl</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls&nbsp;=&nbsp;cons&nbsp;hd&nbsp;tl&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Arith.Minus.html#"><span class="id" title="library">Coq.Arith.Minus</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Arith.Minus.html#minus_n_O"><span class="id" title="lemma">minus_n_O</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;reflexivity&nbsp;no&nbsp;longer&nbsp;works!&nbsp;we&nbsp;need&nbsp;to&nbsp;use&nbsp;a&nbsp;theorem<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;the&nbsp;standard&nbsp;library.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Arith.Minus.html#minus_n_O"><span class="id" title="lemma">minus_n_O</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Formal proofs are finicky ...

</li>
<li> On one hand, we used <span class="inlinecode"><span class="id" title="var">pred</span></span>. On the other hand, we used - 1.

</li>
<li> Semantically they are equivalent. But all the proof assistant sees is a
    bunch of syntax.

</li>
<li> The cost of rigour is extremely high!

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">natlist</span></span> is an example of recursive data structures.

</li>
<li> <span class="inlinecode"><span class="id" title="var">append</span></span> is a recursive function that operates on lists.

</li>
<li> How do we prove stuff about list append?

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatList.append_associative'" class="idref" href="#NatList.append_associative'"><span class="id" title="lemma">append_associative'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="ls1:35" class="idref" href="#ls1:35"><span class="id" title="binder">ls1</span></a> <a id="ls2:36" class="idref" href="#ls2:36"><span class="id" title="binder">ls2</span></a> <a id="ls3:37" class="idref" href="#ls3:37"><span class="id" title="binder">ls3</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#ls1:35"><span class="id" title="variable">ls1</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#ls2:36"><span class="id" title="variable">ls2</span></a><a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">)</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#ls3:37"><span class="id" title="variable">ls3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#ls1:35"><span class="id" title="variable">ls1</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#ls2:36"><span class="id" title="variable">ls2</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#ls3:37"><span class="id" title="variable">ls3</span></a><a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> <span class="id" title="var">ls3</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">ls1</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Oh&nbsp;no,&nbsp;reflexivity&nbsp;does&nbsp;not&nbsp;work!&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> While induction on natural numbers may be familiar, induction on lists
    may be less familiar.

</li>
<li> Recall that every inductive type in Coq comes with an induction principle.

</li>
<li> Let's recall the natural number induction principal first.

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a>.<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;nat_ind:<br/>
&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;any&nbsp;proposition&nbsp;P&nbsp;on&nbsp;natural&nbsp;numbers<br/>
&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;P&nbsp;holds&nbsp;on&nbsp;0<br/>
&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;if&nbsp;P&nbsp;(n&nbsp;+&nbsp;1)&nbsp;holds&nbsp;assuming&nbsp;P&nbsp;n&nbsp;holds&nbsp;for&nbsp;any&nbsp;n<br/>
&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;we&nbsp;can&nbsp;conclude&nbsp;that&nbsp;P&nbsp;n&nbsp;holds&nbsp;for&nbsp;any&nbsp;n.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Now let's look at the induction principal for lists.

</li>
<li> Notice how similar it is to the one for natural numbers.

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#NatList.natlist_ind"><span class="id" title="definition">natlist_ind</span></a>.<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;natlist_ind:<br/>
&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;natlist&nbsp;-&gt;&nbsp;Prop,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;any&nbsp;proposition&nbsp;P&nbsp;on&nbsp;natlist<br/>
&nbsp;&nbsp;P&nbsp;<span class="inlinecode"></span> <span class="inlinecode"></span>&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;P&nbsp;holds&nbsp;on&nbsp;the&nbsp;empty&nbsp;list<br/>
&nbsp;&nbsp;(forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(n0&nbsp;:&nbsp;natlist),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;if&nbsp;P&nbsp;(n&nbsp;::&nbsp;ls)&nbsp;holds&nbsp;assuming&nbsp;P&nbsp;ls&nbsp;holds<br/>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;(n&nbsp;::&nbsp;n0))&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;any&nbsp;list&nbsp;ls<br/>
&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;natlist,&nbsp;P&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;we&nbsp;can&nbsp;conclude&nbsp;that&nbsp;P&nbsp;ls&nbsp;holds&nbsp;for&nbsp;any&nbsp;ls.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Let's compare and contrast the proof for + associative and append associative.

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatList.plus_associative" class="idref" href="#NatList.plus_associative"><span class="id" title="lemma">plus_associative</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="n1:38" class="idref" href="#n1:38"><span class="id" title="binder">n1</span></a> <a id="n2:39" class="idref" href="#n2:39"><span class="id" title="binder">n2</span></a> <a id="n3:40" class="idref" href="#n3:40"><span class="id" title="binder">n3</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#n1:38"><span class="id" title="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="lec_02_fp.html#n2:39"><span class="id" title="variable">n2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="lec_02_fp.html#n3:40"><span class="id" title="variable">n3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#n1:38"><span class="id" title="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#n2:39"><span class="id" title="variable">n2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="lec_02_fp.html#n3:40"><span class="id" title="variable">n3</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> <span class="id" title="var">n3</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n1</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;base&nbsp;case:&nbsp;n1&nbsp;=&nbsp;0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;inductive&nbsp;case:&nbsp;n1&nbsp;=&nbsp;S&nbsp;n1&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatList.append_associative" class="idref" href="#NatList.append_associative"><span class="id" title="lemma">append_associative</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="ls1:41" class="idref" href="#ls1:41"><span class="id" title="binder">ls1</span></a> <a id="ls2:42" class="idref" href="#ls2:42"><span class="id" title="binder">ls2</span></a> <a id="ls3:43" class="idref" href="#ls3:43"><span class="id" title="binder">ls3</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#ls1:41"><span class="id" title="variable">ls1</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#ls2:42"><span class="id" title="variable">ls2</span></a><a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">)</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#ls3:43"><span class="id" title="variable">ls3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#ls1:41"><span class="id" title="variable">ls1</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#ls2:42"><span class="id" title="variable">ls2</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#ls3:43"><span class="id" title="variable">ls3</span></a><a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> <span class="id" title="var">ls3</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls1</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;base&nbsp;case:&nbsp;ls1&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;inductive&nbsp;case:&nbsp;ls1&nbsp;=&nbsp;n&nbsp;::&nbsp;ls5&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;now&nbsp;have&nbsp;an&nbsp;inductive&nbsp;hypothesis&nbsp;IHls1&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHls1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> It's the "same" proof!

</li>
<li> Something to think about: how are naturals and lists related?

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="NatList.reverse" class="idref" href="#NatList.reverse"><span class="id" title="definition">reverse</span></a> (<a id="ls:44" class="idref" href="#ls:44"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>): <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:44"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a> =&gt; <a class="idref" href="lec_02_fp.html#NatList.nil"><span class="id" title="constructor">nil</span></a><br/>
&nbsp;&nbsp;| <span class="id" title="var">hd</span> <a class="idref" href="lec_02_fp.html#NatList.:::x_'::'_x"><span class="id" title="notation">::</span></a> <span class="id" title="var">tl</span> =&gt; <a class="idref" href="lec_02_fp.html#reverse:45"><span class="id" title="definition">reverse</span></a> <span class="id" title="var">tl</span> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a><span class="id" title="var">hd</span><a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatList.rev_length_attempt" class="idref" href="#NatList.rev_length_attempt"><span class="id" title="lemma">rev_length_attempt</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="ls:47" class="idref" href="#ls:47"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> (<a class="idref" href="lec_02_fp.html#NatList.reverse"><span class="id" title="definition">reverse</span></a> <a class="idref" href="lec_02_fp.html#ls:47"><span class="id" title="variable">ls</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#ls:47"><span class="id" title="variable">ls</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls&nbsp;=&nbsp;cons&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;We're&nbsp;stuck!&nbsp;We&nbsp;need&nbsp;a&nbsp;lemma.&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Sometimes when we prove a theorem, we need a Lemma.

</li>
<li> We need something about append and length.

</li>
<li> It's best to come up with the most general theorem statement possible.

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a id="NatList.app_length" class="idref" href="#NatList.app_length"><span class="id" title="lemma">app_length</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="ls1:48" class="idref" href="#ls1:48"><span class="id" title="binder">ls1</span></a> <a id="ls2:49" class="idref" href="#ls2:49"><span class="id" title="binder">ls2</span></a> : <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> (<a class="idref" href="lec_02_fp.html#ls1:48"><span class="id" title="variable">ls1</span></a> <a class="idref" href="lec_02_fp.html#9051c98c6b1a5a76d335ab187bb449a6"><span class="id" title="notation">++</span></a> <a class="idref" href="lec_02_fp.html#ls2:49"><span class="id" title="variable">ls2</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#ls1:48"><span class="id" title="variable">ls1</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#ls2:49"><span class="id" title="variable">ls2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls1</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls1&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls1&nbsp;=&nbsp;cons&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">IHls1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="NatList.rev_length" class="idref" href="#NatList.rev_length"><span class="id" title="lemma">rev_length</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="ls:50" class="idref" href="#ls:50"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> (<a class="idref" href="lec_02_fp.html#NatList.reverse"><span class="id" title="definition">reverse</span></a> <a class="idref" href="lec_02_fp.html#ls:50"><span class="id" title="variable">ls</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#ls:50"><span class="id" title="variable">ls</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ls&nbsp;=&nbsp;cons&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> -&gt; <a class="idref" href="lec_02_fp.html#NatList.app_length"><span class="id" title="lemma">app_length</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Arith.Plus.html#"><span class="id" title="library">Coq.Arith.Plus</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Arith.Plus.html#plus_comm"><span class="id" title="abbreviation">plus_comm</span></a>. <span class="comment">(*&nbsp;Using&nbsp;a&nbsp;"lemma"&nbsp;from&nbsp;another&nbsp;library&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHls</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="lec_02_fp.html#NatList"><span class="id" title="module">NatList</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab8"></a><h2 class="section">Options</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> In our definition of <span class="inlinecode"><span class="id" title="var">head</span></span>, we had to supply a default value.

</li>
<li> We had to do this because Coq forces all functions to be total like
    in mathematics.

</li>
<li> What if we want partial functions which are important in computation?
    We might get a partial function because of computational side-effects:
    errors, non-terminiation, etc. 

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a id="NatOption" class="idref" href="#NatOption"><span class="id" title="module">NatOption</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Import</span> <span class="id" title="var">NatList</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <a class="idref" href="lec_02_fp.html#NatList.head"><span class="id" title="definition">head</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a id="NatOption.natoption" class="idref" href="#NatOption.natoption"><span class="id" title="inductive">natoption</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="NatOption.Some" class="idref" href="#NatOption.Some"><span class="id" title="constructor">Some</span></a> (<a id="n:53" class="idref" href="#n:53"><span class="id" title="binder">n</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;| <a id="NatOption.None" class="idref" href="#NatOption.None"><span class="id" title="constructor">None</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="NatOption.head'" class="idref" href="#NatOption.head'"><span class="id" title="definition">head'</span></a> (<a id="ls:54" class="idref" href="#ls:54"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#NatList.natlist"><span class="id" title="inductive">natlist</span></a>): <a class="idref" href="lec_02_fp.html#NatOption.natoption"><span class="id" title="inductive">natoption</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:54"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#f5cee4f22b9033d1d704f9d537452cd0"><span class="id" title="notation">[]</span></a> =&gt; <a class="idref" href="lec_02_fp.html#NatOption.None"><span class="id" title="constructor">None</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">hd</span> <a class="idref" href="lec_02_fp.html#NatList.:::x_'::'_x"><span class="id" title="notation">::</span></a> <span class="id" title="var">_</span> =&gt; <a class="idref" href="lec_02_fp.html#NatOption.Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">hd</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatOption.head'"><span class="id" title="definition">head'</span></a> <a class="idref" href="lec_02_fp.html#f5cee4f22b9033d1d704f9d537452cd0"><span class="id" title="notation">[]</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#NatOption.head'"><span class="id" title="definition">head'</span></a> <a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">[</span></a>1<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 2<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">;</span></a> 3<a class="idref" href="lec_02_fp.html#62815778618d6f51cd0f9ac90bf0e8be"><span class="id" title="notation">]</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="lec_02_fp.html#NatOption"><span class="id" title="module">NatOption</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab9"></a><h2 class="section">Polymorphism</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> Up until now, we've just worked with products of naturals and lists of naturals.

</li>
<li> In general, we can make products of naturals and integers. Or lists of
    rational numbers.

</li>
<li> In other words, we'd like our data structures to hold any type T.

</li>
<li> This is called *polymorphism*.

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a id="PolyList" class="idref" href="#PolyList"><span class="id" title="module">PolyList</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a id="PolyList.list" class="idref" href="#PolyList.list"><span class="id" title="inductive">list</span></a> (<a id="X:56" class="idref" href="#X:56"><span class="id" title="binder">X</span></a>: <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <a id="PolyList.nil" class="idref" href="#PolyList.nil"><span class="id" title="constructor">nil</span></a> : <a class="idref" href="lec_02_fp.html#list:57"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:56"><span class="id" title="variable">X</span></a><br/>
| <a id="PolyList.cons" class="idref" href="#PolyList.cons"><span class="id" title="constructor">cons</span></a> : <a class="idref" href="lec_02_fp.html#X:56"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#list:57"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:56"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#list:57"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:56"><span class="id" title="variable">X</span></a>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#PolyList.list"><span class="id" title="inductive">list</span></a>.<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;==&gt;&nbsp;<span class="inlinecode"><span class="id" title="var">list</span>:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;Notice&nbsp;how&nbsp;list&nbsp;is&nbsp;no&nbsp;longer&nbsp;<span class="inlinecode"><span class="id" title="keyword">Type</span></span>&nbsp;but&nbsp;<span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.<br/>
&nbsp;&nbsp;&nbsp;In&nbsp;other&nbsp;words,&nbsp;we&nbsp;need&nbsp;to&nbsp;supply&nbsp;a&nbsp;Type.<br/>
&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="PolyList.ls1" class="idref" href="#PolyList.ls1"><span class="id" title="definition">ls1</span></a> := <a class="idref" href="lec_02_fp.html#PolyList.nil"><span class="id" title="constructor">nil</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#PolyList.ls1"><span class="id" title="definition">ls1</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="PolyList.ls1'" class="idref" href="#PolyList.ls1'"><span class="id" title="definition">ls1'</span></a> := <a class="idref" href="lec_02_fp.html#PolyList.nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#PolyList.ls1'"><span class="id" title="definition">ls1'</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Compare <span class="inlinecode"><span class="id" title="var">ls1</span></span> and <span class="inlinecode"><span class="id" title="var">ls1'</span></span>.

</li>
<li> What's the difference in type?  

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="PolyList.ls2" class="idref" href="#PolyList.ls2"><span class="id" title="definition">ls2</span></a> := <a class="idref" href="lec_02_fp.html#PolyList.cons"><span class="id" title="constructor">cons</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> 1 (<a class="idref" href="lec_02_fp.html#PolyList.nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>).<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#PolyList.ls2"><span class="id" title="definition">ls2</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="PolyList.ls3" class="idref" href="#PolyList.ls3"><span class="id" title="definition">ls3</span></a> := <a class="idref" href="lec_02_fp.html#PolyList.cons"><span class="id" title="constructor">cons</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> 2 (<a class="idref" href="lec_02_fp.html#PolyList.cons"><span class="id" title="constructor">cons</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> 1 (<a class="idref" href="lec_02_fp.html#PolyList.nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)).<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#PolyList.ls3"><span class="id" title="definition">ls3</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Our functions on lists now need this extra type argument as well.

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="lec_02_fp.html#NatList.length"><span class="id" title="definition">NatList.length</span></a>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="PolyList.length" class="idref" href="#PolyList.length"><span class="id" title="definition">length</span></a> (<a id="X:59" class="idref" href="#X:59"><span class="id" title="binder">X</span></a>: <span class="id" title="keyword">Type</span>) (<a id="ls:60" class="idref" href="#ls:60"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#PolyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:59"><span class="id" title="variable">X</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:60"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#PolyList.nil"><span class="id" title="constructor">nil</span></a> <span class="id" title="var">_</span> =&gt; 0<br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#PolyList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">tl</span> =&gt; 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="lec_02_fp.html#length:61"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#X:59"><span class="id" title="variable">X</span></a> <span class="id" title="var">tl</span>                              <br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> And so do our theorems ...

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="PolyList.length_cons" class="idref" href="#PolyList.length_cons"><span class="id" title="lemma">length_cons</span></a>:<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<a id="X:63" class="idref" href="#X:63"><span class="id" title="binder">X</span></a>: <span class="id" title="keyword">Type</span>) (<a id="ls:64" class="idref" href="#ls:64"><span class="id" title="binder">ls</span></a>: <a class="idref" href="lec_02_fp.html#PolyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:63"><span class="id" title="variable">X</span></a>) (<a id="x:65" class="idref" href="#x:65"><span class="id" title="binder">x</span></a>: <a class="idref" href="lec_02_fp.html#X:63"><span class="id" title="variable">X</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#PolyList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#X:63"><span class="id" title="variable">X</span></a> (<a class="idref" href="lec_02_fp.html#PolyList.cons"><span class="id" title="constructor">cons</span></a> <a class="idref" href="lec_02_fp.html#X:63"><span class="id" title="variable">X</span></a> <a class="idref" href="lec_02_fp.html#x:65"><span class="id" title="variable">x</span></a> <a class="idref" href="lec_02_fp.html#ls:64"><span class="id" title="variable">ls</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="lec_02_fp.html#PolyList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#X:63"><span class="id" title="variable">X</span></a> <a class="idref" href="lec_02_fp.html#ls:64"><span class="id" title="variable">ls</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="comment">(*&nbsp;It's&nbsp;ok&nbsp;not&nbsp;to&nbsp;use&nbsp;the&nbsp;induction&nbsp;hypothesis!&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;means&nbsp;we&nbsp;could&nbsp;have&nbsp;used&nbsp;destruct&nbsp;instead.&nbsp;*)</span><br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="lec_02_fp.html#PolyList"><span class="id" title="module">PolyList</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab10"></a><h2 class="section">Implicit Arguments</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a id="ImplicitPolyList" class="idref" href="#ImplicitPolyList"><span class="id" title="module">ImplicitPolyList</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Benefit of polymorphism is that it lets us write really general
      data types.

</li>
<li> Downside of polymorphism is that we have all these extra type arguments
      floating around.

</li>
<li> Enter <i>implicit arguments</i>.

</li>
</ul>
  
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a id="ImplicitPolyList.list" class="idref" href="#ImplicitPolyList.list"><span class="id" title="inductive">list</span></a> {<a id="X:66" class="idref" href="#X:66"><span class="id" title="binder">X</span></a>: <span class="id" title="keyword">Type</span>} : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="ImplicitPolyList.nil" class="idref" href="#ImplicitPolyList.nil"><span class="id" title="constructor">nil</span></a> : <a class="idref" href="lec_02_fp.html#list:67"><span class="id" title="inductive">list</span></a><br/>
&nbsp;&nbsp;| <a id="ImplicitPolyList.cons" class="idref" href="#ImplicitPolyList.cons"><span class="id" title="constructor">cons</span></a> : <a class="idref" href="lec_02_fp.html#X:66"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#list:67"><span class="id" title="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#list:67"><span class="id" title="inductive">list</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#ImplicitPolyList.list_ind"><span class="id" title="definition">list_ind</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Notice that everything is the same.

</li>
<li> We will just end up having extra syntactic support.

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Set Printing All</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;can&nbsp;use&nbsp;the&nbsp;@&nbsp;symbol&nbsp;to&nbsp;manually&nbsp;give&nbsp;the&nbsp;arguments&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="ImplicitPolyList.ls1" class="idref" href="#ImplicitPolyList.ls1"><span class="id" title="definition">ls1</span></a> :=  @<a class="idref" href="lec_02_fp.html#ImplicitPolyList.nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#ImplicitPolyList.ls1"><span class="id" title="definition">ls1</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;But&nbsp;Coq&nbsp;can&nbsp;infer&nbsp;it&nbsp;when&nbsp;the&nbsp;data&nbsp;type&nbsp;in&nbsp;the&nbsp;list&nbsp;can&nbsp;be&nbsp;inferred&nbsp;from&nbsp;context.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="ImplicitPolyList.ls2" class="idref" href="#ImplicitPolyList.ls2"><span class="id" title="definition">ls2</span></a> := <a class="idref" href="lec_02_fp.html#ImplicitPolyList.cons"><span class="id" title="constructor">cons</span></a> 1 <a class="idref" href="lec_02_fp.html#ImplicitPolyList.nil"><span class="id" title="constructor">nil</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#ImplicitPolyList.ls2"><span class="id" title="definition">ls2</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="ImplicitPolyList.ls3" class="idref" href="#ImplicitPolyList.ls3"><span class="id" title="definition">ls3</span></a> := <a class="idref" href="lec_02_fp.html#ImplicitPolyList.cons"><span class="id" title="constructor">cons</span></a> 2 (<a class="idref" href="lec_02_fp.html#ImplicitPolyList.cons"><span class="id" title="constructor">cons</span></a> 1 <a class="idref" href="lec_02_fp.html#ImplicitPolyList.nil"><span class="id" title="constructor">nil</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#ImplicitPolyList.ls3"><span class="id" title="definition">ls3</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Rewriting the <span class="inlinecode"><span class="id" title="var">length</span></span> function from before with implicit arguments.

</li>
<li> Notice how many type arguments go away.

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a id="ImplicitPolyList.length" class="idref" href="#ImplicitPolyList.length"><span class="id" title="definition">length</span></a> {<a id="X:69" class="idref" href="#X:69"><span class="id" title="binder">X</span></a>: <span class="id" title="keyword">Type</span>} (<a id="ls:70" class="idref" href="#ls:70"><span class="id" title="binder">ls</span></a>: @<a class="idref" href="lec_02_fp.html#ImplicitPolyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:69"><span class="id" title="variable">X</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:70"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#ImplicitPolyList.nil"><span class="id" title="constructor">nil</span></a>  =&gt; 0<br/>
&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#ImplicitPolyList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">tl</span> =&gt; 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="lec_02_fp.html#length:71"><span class="id" title="definition">length</span></a> <span class="id" title="var">tl</span>                              <br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Unset Printing All</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> This also works for Theorems.

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a id="ImplicitPolyList.length_cons" class="idref" href="#ImplicitPolyList.length_cons"><span class="id" title="lemma">length_cons</span></a>:<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<a id="X:73" class="idref" href="#X:73"><span class="id" title="binder">X</span></a>: <span class="id" title="keyword">Type</span>) (<a id="ls:74" class="idref" href="#ls:74"><span class="id" title="binder">ls</span></a>: @<a class="idref" href="lec_02_fp.html#ImplicitPolyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:73"><span class="id" title="variable">X</span></a>) (<a id="x:75" class="idref" href="#x:75"><span class="id" title="binder">x</span></a>: <a class="idref" href="lec_02_fp.html#X:73"><span class="id" title="variable">X</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#ImplicitPolyList.length"><span class="id" title="definition">length</span></a> (<a class="idref" href="lec_02_fp.html#ImplicitPolyList.cons"><span class="id" title="constructor">cons</span></a> <a class="idref" href="lec_02_fp.html#x:75"><span class="id" title="variable">x</span></a> <a class="idref" href="lec_02_fp.html#ls:74"><span class="id" title="variable">ls</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="lec_02_fp.html#ImplicitPolyList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="lec_02_fp.html#ls:74"><span class="id" title="variable">ls</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="lec_02_fp.html#ImplicitPolyList"><span class="id" title="module">ImplicitPolyList</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Of course, the Coq standard library has lists and theorems on lists.

</li>
<li> Note that what we formalized is different. 

</li>
</ul>

</div>
<div class="code">
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a>.<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab11"></a><h2 class="section">Polymorphic Product Types</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a id="PolyProd" class="idref" href="#PolyProd"><span class="id" title="module">PolyProd</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> We can of course quantify over multiple generic types.

</li>
<li> We'll show an example with products.

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a id="PolyProd.prod" class="idref" href="#PolyProd.prod"><span class="id" title="inductive">prod</span></a> (<a id="X:76" class="idref" href="#X:76"><span class="id" title="binder">X</span></a> <a id="Y:77" class="idref" href="#Y:77"><span class="id" title="binder">Y</span></a>: <span class="id" title="keyword">Type</span>): <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="PolyProd.pair" class="idref" href="#PolyProd.pair"><span class="id" title="constructor">pair</span></a> : <a class="idref" href="lec_02_fp.html#X:76"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:77"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#prod:78"><span class="id" title="inductive">prod</span></a> <a class="idref" href="lec_02_fp.html#X:76"><span class="id" title="variable">X</span></a> <a class="idref" href="lec_02_fp.html#Y:77"><span class="id" title="variable">Y</span></a>. <span class="comment">(*&nbsp;compare&nbsp;with&nbsp;previous&nbsp;definition&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Let's make the arguments implicit 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">Arguments</span> <a class="idref" href="lec_02_fp.html#PolyProd.pair"><span class="id" title="constructor">pair</span></a> {<span class="id" title="var">X</span>} {<span class="id" title="var">Y</span>}.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <a class="idref" href="lec_02_fp.html#PolyProd.pair"><span class="id" title="constructor">pair</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#PolyProd.pair"><span class="id" title="constructor">pair</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#PolyProd.pair"><span class="id" title="constructor">pair</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;==&gt;&nbsp;prod&nbsp;nat&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Still can give the implicit arguments explicitly.

</li>
</ul>
   
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> @<a class="idref" href="lec_02_fp.html#PolyProd.pair"><span class="id" title="constructor">pair</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Notation still works.

</li>
</ul>
   
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a id="110452b4b4a4f8c49efd517f91547ee9" class="idref" href="#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">&quot;</span></a>( x , y )" := (<a class="idref" href="lec_02_fp.html#PolyProd.pair"><span class="id" title="constructor">pair</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><a class="idref" href="lec_02_fp.html#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">,</span></a> 20<a class="idref" href="lec_02_fp.html#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;==&gt;&nbsp;prod&nbsp;nat&nbsp;bool&nbsp;*)</span><br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a><a class="idref" href="lec_02_fp.html#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="lec_02_fp.html#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;==&gt;&nbsp;prod&nbsp;nat&nbsp;Type&nbsp;*)</span><br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="PolyProd.fst" class="idref" href="#PolyProd.fst"><span class="id" title="definition">fst</span></a> {<a id="X:80" class="idref" href="#X:80"><span class="id" title="binder">X</span></a> <a id="Y:81" class="idref" href="#Y:81"><span class="id" title="binder">Y</span></a>: <span class="id" title="keyword">Type</span>} (<a id="p:82" class="idref" href="#p:82"><span class="id" title="binder">p</span></a>: <a class="idref" href="lec_02_fp.html#PolyProd.prod"><span class="id" title="inductive">prod</span></a> <a class="idref" href="lec_02_fp.html#X:80"><span class="id" title="variable">X</span></a> <a class="idref" href="lec_02_fp.html#Y:81"><span class="id" title="variable">Y</span></a>): <a class="idref" href="lec_02_fp.html#X:80"><span class="id" title="variable">X</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#p:82"><span class="id" title="variable">p</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#PolyProd.pair"><span class="id" title="constructor">pair</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#PolyProd.fst"><span class="id" title="definition">fst</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="PolyProd.snd" class="idref" href="#PolyProd.snd"><span class="id" title="definition">snd</span></a> {<a id="X:84" class="idref" href="#X:84"><span class="id" title="binder">X</span></a> <a id="Y:85" class="idref" href="#Y:85"><span class="id" title="binder">Y</span></a>: <span class="id" title="keyword">Type</span>} (<a id="p:86" class="idref" href="#p:86"><span class="id" title="binder">p</span></a>: <a class="idref" href="lec_02_fp.html#PolyProd.prod"><span class="id" title="inductive">prod</span></a> <a class="idref" href="lec_02_fp.html#X:84"><span class="id" title="variable">X</span></a> <a class="idref" href="lec_02_fp.html#Y:85"><span class="id" title="variable">Y</span></a>): <a class="idref" href="lec_02_fp.html#Y:85"><span class="id" title="variable">Y</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#p:86"><span class="id" title="variable">p</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="lec_02_fp.html#PolyProd.pair"><span class="id" title="constructor">pair</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a id="PolyProd.surjective_pairing" class="idref" href="#PolyProd.surjective_pairing"><span class="id" title="lemma">surjective_pairing</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<a id="X:88" class="idref" href="#X:88"><span class="id" title="binder">X</span></a> <a id="Y:89" class="idref" href="#Y:89"><span class="id" title="binder">Y</span></a>: <span class="id" title="keyword">Type</span>) (<a id="p:90" class="idref" href="#p:90"><span class="id" title="binder">p</span></a> : <a class="idref" href="lec_02_fp.html#PolyProd.prod"><span class="id" title="inductive">prod</span></a> <a class="idref" href="lec_02_fp.html#X:88"><span class="id" title="variable">X</span></a> <a class="idref" href="lec_02_fp.html#Y:89"><span class="id" title="variable">Y</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#p:90"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#PolyProd.fst"><span class="id" title="definition">fst</span></a> <a class="idref" href="lec_02_fp.html#p:90"><span class="id" title="variable">p</span></a><a class="idref" href="lec_02_fp.html#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">,</span></a> <a class="idref" href="lec_02_fp.html#PolyProd.snd"><span class="id" title="definition">snd</span></a> <a class="idref" href="lec_02_fp.html#p:90"><span class="id" title="variable">p</span></a><a class="idref" href="lec_02_fp.html#110452b4b4a4f8c49efd517f91547ee9"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="lec_02_fp.html#PolyProd"><span class="id" title="module">PolyProd</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab12"></a><h2 class="section">Higher-Order Functions in Coq</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a id="HigherOrderFunctions" class="idref" href="#HigherOrderFunctions"><span class="id" title="module">HigherOrderFunctions</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> We'll now introduce the concept of a <i>higher-order function</i>.

</li>
<li> This might also be called <i>first-class function</i>.

</li>
<li> And is related to *anonymous function*.

</li>
<li> In my opinion, this is one of the most important abstractions ever
       developed.

</li>
<li> You may be wondering why we talked about products and polymorphism
       before we talk about a special kind of function. These concepts will
       appear when we talk about higher-order functions.

</li>
</ul>
   
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> Before we get to higher-order functions, it's helpful to introduce the
       idea of an  anonymous function first.

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.idNat" class="idref" href="#HigherOrderFunctions.idNat"><span class="id" title="definition">idNat</span></a> (<a id="x:91" class="idref" href="#x:91"><span class="id" title="binder">x</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>): <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#x:91"><span class="id" title="variable">x</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.idNat"><span class="id" title="definition">idNat</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.idNat"><span class="id" title="definition">idNat</span></a> 1.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.idNat"><span class="id" title="definition">idNat</span></a> 2.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> That was a lot of work to define an identity function.

</li>
<li> In particular, we had to come up with a name for the function.

</li>
<li> An <i>anonymous</i> function provides a way to write a function without giving it a name.

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">fun</span> <a id="x:92" class="idref" href="#x:92"><span class="id" title="binder">x</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="lec_02_fp.html#x:92"><span class="id" title="variable">x</span></a>). <span class="comment">(*&nbsp;idNat&nbsp;as&nbsp;an&nbsp;anonymous&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">fun</span> <a id="x:93" class="idref" href="#x:93"><span class="id" title="binder">x</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="lec_02_fp.html#x:93"><span class="id" title="variable">x</span></a>) 1.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">fun</span> <a id="x:94" class="idref" href="#x:94"><span class="id" title="binder">x</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="lec_02_fp.html#x:94"><span class="id" title="variable">x</span></a>) 2.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> We can give an anonymous function a name by assigning it one.

</li>
<li> If your language enables you to assign a function to a variable,
       then your language supports <i>first-class</i> or <i>higher-order</i> functions.

</li>
<li> Note how the types change.

</li>
</ul>
   
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.idNat'" class="idref" href="#HigherOrderFunctions.idNat'"><span class="id" title="definition">idNat'</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="x:95" class="idref" href="#x:95"><span class="id" title="binder">x</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="lec_02_fp.html#x:95"><span class="id" title="variable">x</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.idNat'"><span class="id" title="definition">idNat'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.idNat'"><span class="id" title="definition">idNat'</span></a> 1.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.idNat'"><span class="id" title="definition">idNat'</span></a> 2.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> Wait ... can we make an anonymous function a body of another anonymous function?

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="keyword">fun</span> <a id="x:96" class="idref" href="#x:96"><span class="id" title="binder">x</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; (<span class="id" title="keyword">fun</span> <a id="y:97" class="idref" href="#y:97"><span class="id" title="binder">y</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="lec_02_fp.html#y:97"><span class="id" title="variable">y</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> (<span class="id" title="keyword">fun</span> <a id="x:98" class="idref" href="#x:98"><span class="id" title="binder">x</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <span class="id" title="keyword">fun</span> <a id="y:99" class="idref" href="#y:99"><span class="id" title="binder">y</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="lec_02_fp.html#y:99"><span class="id" title="variable">y</span></a>) 1.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> (<span class="id" title="keyword">fun</span> <a id="x:100" class="idref" href="#x:100"><span class="id" title="binder">x</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <span class="id" title="keyword">fun</span> <a id="y:101" class="idref" href="#y:101"><span class="id" title="binder">y</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="lec_02_fp.html#y:101"><span class="id" title="variable">y</span></a>) 1 2.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.whatAmI" class="idref" href="#HigherOrderFunctions.whatAmI"><span class="id" title="definition">whatAmI</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="x:102" class="idref" href="#x:102"><span class="id" title="binder">x</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <span class="id" title="keyword">fun</span> <a id="y:103" class="idref" href="#y:103"><span class="id" title="binder">y</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="lec_02_fp.html#y:103"><span class="id" title="variable">y</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.whatAmI1" class="idref" href="#HigherOrderFunctions.whatAmI1"><span class="id" title="definition">whatAmI1</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#HigherOrderFunctions.whatAmI"><span class="id" title="definition">whatAmI</span></a> 1.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.whatAmI2" class="idref" href="#HigherOrderFunctions.whatAmI2"><span class="id" title="definition">whatAmI2</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#HigherOrderFunctions.whatAmI1"><span class="id" title="definition">whatAmI1</span></a> 2.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.whatAmI"><span class="id" title="definition">whatAmI</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.whatAmI1"><span class="id" title="definition">whatAmI1</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.whatAmI2"><span class="id" title="definition">whatAmI2</span></a>.<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> And we can keep going for any natural n.

</li>
<li> We have just arrived at higher-order functions.

</li>
</ul>
   
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> Does whatAmI look familiar?

</li>
<li> It's exactly <span class="inlinecode"><span class="id" title="var">snd</span></span> for nat prod!

</li>
<li> Higher-order functions or lambdas are extremely powerful. They can be
        used to formulate any computation. We have just stumbled upon what is
        called a Church encoding for pairs.

</li>
<li> Let's add the polymorphism back in.

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.churchPair" class="idref" href="#HigherOrderFunctions.churchPair"><span class="id" title="definition">churchPair</span></a> {<a id="X:104" class="idref" href="#X:104"><span class="id" title="binder">X</span></a> <a id="Y:105" class="idref" href="#Y:105"><span class="id" title="binder">Y</span></a> <a id="P:106" class="idref" href="#P:106"><span class="id" title="binder">P</span></a>: <span class="id" title="keyword">Type</span>}: <a class="idref" href="lec_02_fp.html#X:104"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:105"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#X:104"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:105"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#P:106"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#P:106"><span class="id" title="variable">P</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="x:107" class="idref" href="#x:107"><span class="id" title="binder">x</span></a> =&gt; <span class="id" title="keyword">fun</span> <a id="y:108" class="idref" href="#y:108"><span class="id" title="binder">y</span></a> =&gt; <span class="id" title="keyword">fun</span> <a id="p:109" class="idref" href="#p:109"><span class="id" title="binder">p</span></a> =&gt; <a class="idref" href="lec_02_fp.html#p:109"><span class="id" title="variable">p</span></a> <a class="idref" href="lec_02_fp.html#x:107"><span class="id" title="variable">x</span></a> <a class="idref" href="lec_02_fp.html#y:108"><span class="id" title="variable">y</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.churchFst" class="idref" href="#HigherOrderFunctions.churchFst"><span class="id" title="definition">churchFst</span></a> {<a id="X:110" class="idref" href="#X:110"><span class="id" title="binder">X</span></a> <a id="Y:111" class="idref" href="#Y:111"><span class="id" title="binder">Y</span></a>: <span class="id" title="keyword">Type</span>} : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">((</span></a><a class="idref" href="lec_02_fp.html#X:110"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:111"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#X:110"><span class="id" title="variable">X</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#X:110"><span class="id" title="variable">X</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#X:110"><span class="id" title="variable">X</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="p:112" class="idref" href="#p:112"><span class="id" title="binder">p</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#X:110"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:111"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#X:110"><span class="id" title="variable">X</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#X:110"><span class="id" title="variable">X</span></a> =&gt; <a class="idref" href="lec_02_fp.html#p:112"><span class="id" title="variable">p</span></a> (<span class="id" title="keyword">fun</span> <a id="x:113" class="idref" href="#x:113"><span class="id" title="binder">x</span></a>: <a class="idref" href="lec_02_fp.html#X:110"><span class="id" title="variable">X</span></a> =&gt; <span class="id" title="keyword">fun</span> <a id="y:114" class="idref" href="#y:114"><span class="id" title="binder">y</span></a>: <a class="idref" href="lec_02_fp.html#Y:111"><span class="id" title="variable">Y</span></a> =&gt; <a class="idref" href="lec_02_fp.html#x:113"><span class="id" title="variable">x</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.churchSnd" class="idref" href="#HigherOrderFunctions.churchSnd"><span class="id" title="definition">churchSnd</span></a> {<a id="X:115" class="idref" href="#X:115"><span class="id" title="binder">X</span></a> <a id="Y:116" class="idref" href="#Y:116"><span class="id" title="binder">Y</span></a>: <span class="id" title="keyword">Type</span>} : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">((</span></a><a class="idref" href="lec_02_fp.html#X:115"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:116"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:116"><span class="id" title="variable">Y</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:116"><span class="id" title="variable">Y</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:116"><span class="id" title="variable">Y</span></a>:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="p:117" class="idref" href="#p:117"><span class="id" title="binder">p</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#X:115"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:116"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:116"><span class="id" title="variable">Y</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:116"><span class="id" title="variable">Y</span></a> =&gt; <a class="idref" href="lec_02_fp.html#p:117"><span class="id" title="variable">p</span></a> (<span class="id" title="keyword">fun</span> <a id="x:118" class="idref" href="#x:118"><span class="id" title="binder">x</span></a>: <a class="idref" href="lec_02_fp.html#X:115"><span class="id" title="variable">X</span></a> =&gt; <span class="id" title="keyword">fun</span> <a id="y:119" class="idref" href="#y:119"><span class="id" title="binder">y</span></a>: <a class="idref" href="lec_02_fp.html#Y:116"><span class="id" title="variable">Y</span></a> =&gt; <a class="idref" href="lec_02_fp.html#y:119"><span class="id" title="variable">y</span></a>).<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.churchFst"><span class="id" title="definition">churchFst</span></a> (<a class="idref" href="lec_02_fp.html#HigherOrderFunctions.churchPair"><span class="id" title="definition">churchPair</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.churchFst"><span class="id" title="definition">churchFst</span></a> (<a class="idref" href="lec_02_fp.html#HigherOrderFunctions.churchPair"><span class="id" title="definition">churchPair</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Compute</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.churchSnd"><span class="id" title="definition">churchSnd</span></a> (<a class="idref" href="lec_02_fp.html#HigherOrderFunctions.churchPair"><span class="id" title="definition">churchPair</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> There is a deeper relation between higher-order functions and products.

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Locate</span> "*".<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.curry" class="idref" href="#HigherOrderFunctions.curry"><span class="id" title="definition">curry</span></a> {<a id="X:120" class="idref" href="#X:120"><span class="id" title="binder">X</span></a> <a id="Y:121" class="idref" href="#Y:121"><span class="id" title="binder">Y</span></a> <a id="Z:122" class="idref" href="#Z:122"><span class="id" title="binder">Z</span></a>: <span class="id" title="keyword">Type</span>} (<a id="f:123" class="idref" href="#f:123"><span class="id" title="binder">f</span></a>: <a class="idref" href="lec_02_fp.html#X:120"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="lec_02_fp.html#Y:121"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Z:122"><span class="id" title="variable">Z</span></a>): <a class="idref" href="lec_02_fp.html#X:120"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#Y:121"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Z:122"><span class="id" title="variable">Z</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="x:124" class="idref" href="#x:124"><span class="id" title="binder">x</span></a>: <a class="idref" href="lec_02_fp.html#X:120"><span class="id" title="variable">X</span></a>) =&gt; <span class="id" title="keyword">fun</span> (<a id="y:125" class="idref" href="#y:125"><span class="id" title="binder">y</span></a>: <a class="idref" href="lec_02_fp.html#Y:121"><span class="id" title="variable">Y</span></a>) =&gt; <a class="idref" href="lec_02_fp.html#f:123"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="lec_02_fp.html#x:124"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="lec_02_fp.html#y:125"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a id="HigherOrderFunctions.uncurry" class="idref" href="#HigherOrderFunctions.uncurry"><span class="id" title="definition">uncurry</span></a> {<a id="X:126" class="idref" href="#X:126"><span class="id" title="binder">X</span></a> <a id="Y:127" class="idref" href="#Y:127"><span class="id" title="binder">Y</span></a> <a id="Z:128" class="idref" href="#Z:128"><span class="id" title="binder">Z</span></a>: <span class="id" title="keyword">Type</span>} (<a id="f:129" class="idref" href="#f:129"><span class="id" title="binder">f</span></a>: <a class="idref" href="lec_02_fp.html#X:126"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:127"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Z:128"><span class="id" title="variable">Z</span></a>): <a class="idref" href="lec_02_fp.html#X:126"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="lec_02_fp.html#Y:127"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Z:128"><span class="id" title="variable">Z</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="p:130" class="idref" href="#p:130"><span class="id" title="binder">p</span></a> =&gt; <a class="idref" href="lec_02_fp.html#f:129"><span class="id" title="variable">f</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#fst"><span class="id" title="definition">fst</span></a> <a class="idref" href="lec_02_fp.html#p:130"><span class="id" title="variable">p</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#snd"><span class="id" title="definition">snd</span></a> <a class="idref" href="lec_02_fp.html#p:130"><span class="id" title="variable">p</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a id="HigherOrderFunctions.curry_uncurry" class="idref" href="#HigherOrderFunctions.curry_uncurry"><span class="id" title="lemma">curry_uncurry</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<a id="X:131" class="idref" href="#X:131"><span class="id" title="binder">X</span></a> <a id="Y:132" class="idref" href="#Y:132"><span class="id" title="binder">Y</span></a> <a id="Z:133" class="idref" href="#Z:133"><span class="id" title="binder">Z</span></a>: <span class="id" title="keyword">Type</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="f:134" class="idref" href="#f:134"><span class="id" title="binder">f</span></a>: <a class="idref" href="lec_02_fp.html#X:131"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:132"><span class="id" title="variable">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Z:133"><span class="id" title="variable">Z</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="lec_02_fp.html#HigherOrderFunctions.curry"><span class="id" title="definition">curry</span></a> (<a class="idref" href="lec_02_fp.html#HigherOrderFunctions.uncurry"><span class="id" title="definition">uncurry</span></a> <a class="idref" href="lec_02_fp.html#f:134"><span class="id" title="variable">f</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="lec_02_fp.html#f:134"><span class="id" title="variable">f</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.curry"><span class="id" title="definition">curry</span></a>. <span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" title="tactic">unfold</span></span>&nbsp;tactic&nbsp;tells&nbsp;Coq&nbsp;to&nbsp;"unfold"&nbsp;the&nbsp;definition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;the&nbsp;context&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions.uncurry"><span class="id" title="definition">uncurry</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="keyword">fun</span> <a id="x:137" class="idref" href="#x:137"><span class="id" title="binder">x</span></a> <a id="y:138" class="idref" href="#y:138"><span class="id" title="binder">y</span></a> =&gt; <span class="id" title="var">f</span> <a class="idref" href="lec_02_fp.html#x:135"><span class="id" title="variable">x</span></a> <a class="idref" href="lec_02_fp.html#y:136"><span class="id" title="variable">y</span></a>) <span class="id" title="keyword">with</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Useful higher-order functions on lists.

</li>
</ul>
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a id="HigherOrderFunctions.filter" class="idref" href="#HigherOrderFunctions.filter"><span class="id" title="definition">filter</span></a> {<a id="X:139" class="idref" href="#X:139"><span class="id" title="binder">X</span></a>: <span class="id" title="keyword">Type</span>} (<a id="predicate:140" class="idref" href="#predicate:140"><span class="id" title="binder">predicate</span></a>: <a class="idref" href="lec_02_fp.html#X:139"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) (<a id="ls:141" class="idref" href="#ls:141"><span class="id" title="binder">ls</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:139"><span class="id" title="variable">X</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:139"><span class="id" title="variable">X</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:141"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="lec_02_fp.html#predicate:140"><span class="id" title="variable">predicate</span></a> <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">h</span> (<a class="idref" href="lec_02_fp.html#filter:142"><span class="id" title="definition">filter</span></a> <a class="idref" href="lec_02_fp.html#predicate:140"><span class="id" title="variable">predicate</span></a> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="lec_02_fp.html#filter:142"><span class="id" title="definition">filter</span></a> <a class="idref" href="lec_02_fp.html#predicate:140"><span class="id" title="variable">predicate</span></a> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a id="HigherOrderFunctions.map" class="idref" href="#HigherOrderFunctions.map"><span class="id" title="definition">map</span></a> {<a id="X:144" class="idref" href="#X:144"><span class="id" title="binder">X</span></a> <a id="Y:145" class="idref" href="#Y:145"><span class="id" title="binder">Y</span></a>: <span class="id" title="keyword">Type</span>} (<a id="f:146" class="idref" href="#f:146"><span class="id" title="binder">f</span></a>: <a class="idref" href="lec_02_fp.html#X:144"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="lec_02_fp.html#Y:145"><span class="id" title="variable">Y</span></a>) (<a id="ls:147" class="idref" href="#ls:147"><span class="id" title="binder">ls</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#X:144"><span class="id" title="variable">X</span></a>): <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="lec_02_fp.html#Y:145"><span class="id" title="variable">Y</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="lec_02_fp.html#ls:147"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">hd</span> <span class="id" title="var">tl</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/V8.12.2/stdlib//Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> (<a class="idref" href="lec_02_fp.html#f:146"><span class="id" title="variable">f</span></a> <span class="id" title="var">hd</span>) (<a class="idref" href="lec_02_fp.html#map:148"><span class="id" title="definition">map</span></a> <a class="idref" href="lec_02_fp.html#f:146"><span class="id" title="variable">f</span></a> <span class="id" title="var">tl</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="lec_02_fp.html#HigherOrderFunctions"><span class="id" title="module">HigherOrderFunctions</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab13"></a><h2 class="section">Summary</h2>


<div class="paragraph"> </div>

<ul class="doclist">
<li> We covered more data types in Coq including product, lists, and
    natural numbers.

</li>
<li> We covered polymorphism in Coq.

</li>
<li> We covered higher-order functions in Coq.

</li>
</ul>
 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>